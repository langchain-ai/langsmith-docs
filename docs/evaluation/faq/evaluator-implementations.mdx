---
sidebar_label: How to use off-the-shelf LangChain evaluators
sidebar_position: 6
---
import {
  CodeTabs,
  PythonBlock,
  TypeScriptBlock,
} from "@site/src/components/InstructionsWithCode";

# How to use off-the-shelf LangChain evaluators
LangChain's evaluation module provides evaluators you can use as-is for common evaluation scenarios.

It's easy to use these by passing them to the `evaluators` argument of the `evaluate()` function. You can check out the [linked doc](https://python.langchain.com/docs/guides/langsmith) for a quick walkthrough of how to use it.

Copy the code snippets below to get started. You can also configure them for your applications using the arguments mentioned in the "Parameters" sections.
If you don't see an implementation that suits your needs, you can learn how to create your own [Custom Run Evaluators](custom-evaluators) in the linked guide, or contribute an string evaluator to the [LangChain repository](https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/evaluation/).

:::note
Most of these evaluators are useful but imperfect! We recommend against blind trust of any single automated metric and to always incorporate them as a part of a holistic testing and evaluation strategy.
Many of the LLM-based evaluators return a binary score for a given data point, so measuring differences in prompt or model performance are most reliable in aggregate over a larger dataset.
:::

## Correctness: QA evaluation
QA evalutors help to measure the correctness of a response to a user query or question. If you have a dataset with reference labels or reference context docs, these are the evaluators for you!
Three QA evaluators you can load are: `"qa"`, `"context_qa"`, `"cot_qa"`. Based on our meta-evals, we recommend using `"cot_qa"` or a similar prompt for best results.
- The `"qa"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.qa.eval_chain.QAEvalChain.html#langchain-evaluation-qa-eval-chain-qaevalchain)) instructs an llm to directly grade a response as "correct" or "incorrect" based on the reference answer.
- The `"context_qa"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.qa.eval_chain.ContextQAEvalChain.html#langchain.evaluation.qa.eval_chain.ContextQAEvalChain)) instructs the LLM chain to use reference "context" (provided throught the example outputs) in determining correctness. This is useful if you have a larger corpus of grounding docs but don't have ground truth answers to a query. 
- The `"cot_qa"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.qa.eval_chain.CotQAEvalChain.html#langchain.evaluation.qa.eval_chain.CotQAEvalChain)) is similar to the "context_qa" evaluator, except it instructs the LLMChain to use chain of thought "reasoning" before determining a final verdict. This tends to lead to responses that better correlate with human labels, for a slightly higher token and runtime cost.
<CodeTabs
  tabs={[
    PythonBlock(`from langsmith import Client
from langsmith.evaluation import LangChainStringEvaluator, evaluate\n
qa_evaluator = LangChainStringEvaluator("qa")  
context_qa_evaluator = LangChainStringEvaluator("context_qa")
cot_qa_evaluator = LangChainStringEvaluator("cot_qa")\n
client = Client()
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>",
    evaluators=[qa_evaluator, context_qa_evaluator, cot_qa_evaluator],
    metadata={"project_name": "<the name to assign to this test project>"},
)`),
  ]}
  groupId="client-language"
/>
You can customize the evaluator by specifying the LLM used to power its LLM chain or even by customizing the prompt itself.
Below is an example using an Anthropic model to run the evaluator, and a custom prompt for the base QA evaluator. Check out the reference docs for more information on the expected prompt format.
<CodeTabs
  tabs={[
    PythonBlock(`from langchain.chat_models import ChatAnthropic
from langchain_core.prompts.prompt import PromptTemplate
from langsmith.evaluation import LangChainStringEvaluator\n
_PROMPT_TEMPLATE = """You are an expert professor specialized in grading students' answers to questions.
You are grading the following question:
{input}
Here is the real answer:
{reference}
You are grading the following predicted answer:
{prediction}
Respond with CORRECT or INCORRECT:
Grade:
"""\n
PROMPT = PromptTemplate(
    input_variables=["input", "reference", "prediction"], template=_PROMPT_TEMPLATE
)
eval_llm = ChatAnthropic(temperature=0.0)\n
qa_evaluator = LangChainStringEvaluator("qa", config={"llm": eval_llm, "prompt": PROMPT})  
context_qa_evaluator = LangChainStringEvaluator("context_qa", config={"llm": eval_llm})
cot_qa_evaluator = LangChainStringEvaluator("cot_qa", config={"llm": eval_llm})
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>", 
    evaluators=[qa_evaluator, context_qa_evaluator, cot_qa_evaluator],
)
`),
  ]}
  groupId="client-language"
/>
## No labels: criteria evaluation
If you don't have ground truth reference labels (i.e., if you are evaluating against production data or if your task doesn't involve factuality), you can evaluate your run against a custom set of criteria using the `"criteria"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.criteria.eval_chain.CriteriaEvalChain.html)).
This is helpful when there are high level semantic aspects of your model's output you'd like to monitor that aren't captured by other explicit checks or rules.
<CodeTabs
  tabs={[
    PythonBlock(`from langsmith.evaluation import LangChainStringEvaluator, evaluate\n
criteria_evaluator = LangChainStringEvaluator(
    "labeled_criteria",
    config={
        "criteria": {
            "creativity": "Is this submission creative, imaginative, or novel?",
            "conciseness": "Is this response concise and to the point?",
        }
    }
)\n
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>",
    evaluators=[criteria_evaluator],
)`),
  ]}
  groupId="client-language"
/>

## Criteria with labels
Your dataset may have ground truth labels or contextual information demonstrating an output that satisfies a criterion or prediction for a certain input. You can use criteria in context with the `"labeled_criteria"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.criteria.eval_chain.LabeledCriteriaEvalChain.html)).
<CodeTabs
  tabs={[
    PythonBlock(`from langsmith import Client
from langsmith.schemas import Example, Run
from langsmith.evaluation import LangChainStringEvaluator, evaluate\n
def prepare_data(run: Run, example: Example):
    return {
        "prediction": run.outputs["output"], 
        "reference": example.outputs["answer"],
        "input": example.inputs["question"],
    }\n       
labeled_criteria_eval = LangChainStringEvaluator(
    "labeled_criteria", 
    config={
        "criteria": {
            "helpfulness": (
                "Is this submission helpful to the user,"  
                " taking into account the correct reference answer?"
            )
        }
    },
    prepare_data=prepare_data,
)\n
client = Client()
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>",
    evaluators=[labeled_criteria_eval],
)    
`),
  ]}
  groupId="client-language"
/>

::::tip Supported Criteria
Default criteria are implemented for the following aspects: conciseness, relevance, correctness, coherence, harmfulness, maliciousness, helpfulness, controversiality, misogyny, and criminality.
To specify custom criteria, write a mapping of a criterion name to its description, such as:
```
    criterion = {"creativity": "Is this submission creative, imaginative, or novel?"}
    criteria_evaluator = LangChainStringEvaluator(
        "labeled_criteria", 
        config={"criteria": criterion}
    )  
```
::::
::::tip Interpreting the Score
Evaluation scores don't have an inherent "direction" (i.e., higher is not necessarily better).
The direction of the score depends on the criteria being evaluated. For example, a score of 1 for "helpfulness" means that the prediction was deemed to be helpful by the model.
However, a score of 1 for "maliciousness" means that the prediction contains malicious content, which, of course, is "bad".
::::
# Embedding distance
One way to quantify the semantic (dis-)similarity between a predicted output and a ground truth is via embedding distance.
You can use the `"embedding_distance"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.embedding_distance.base.EmbeddingDistanceEvalChain.html)) to measure the distance between the predicted output and the ground truth.
<CodeTabs
  tabs={[
    PythonBlock(`from langsmith import Client
from langsmith.evaluation import LangChainStringEvaluator, evaluate
from langchain.embeddings import HuggingFaceEmbeddings\n
embedding_distance_eval = LangChainStringEvaluator("embedding_distance")
# Or to customize the embeddings:
# Requires 'pip install sentence_transformers'
# embedding_distance_eval = LangChainStringEvaluator(
#     "embedding_distance",
#     config={"embeddings": HuggingFaceEmbeddings(), "distance_metric": "cosine"}
# )\n
client = Client()  
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>",
    evaluators=[embedding_distance_eval],
)`),
  ]}
  groupId="client-language"
/>

# String distance
Another simple way to measure similarity is by computing a string edit distance like Levenshtein distance. You can use the `"string_distance"` evaluator ([reference](https://api.python.langchain.com/en/latest/evaluation/langchain.evaluation.string_distance.base.StringDistanceEvalChain.html))to measure the distance between the predicted output and the ground truth. This depends on the `rapidfuzz` library.
<CodeTabs
  tabs={[
    PythonBlock(`from langsmith import Client
from langsmith.evaluation import LangChainStringEvaluator, evaluate\n
string_distance_eval = LangChainStringEvaluator("string_distance")
# Or to customize:  
# string_distance_eval = LangChainStringEvaluator(
#     "string_distance", 
#     config={"distance": "levenshtein", "normalize_score": True}
# )\n
client = Client()
evaluate(
    <LLM or chain or agent>,
    data="<dataset_name>", 
    evaluators=[string_distance_eval],
)`),
  ]}
  groupId="client-language"
/>

## Don't see what you're looking for?

These implementations are just a starting point. We want to work with you to build better off-the-shelf evaluation tools for everyone. 
We'd love feedback and contributions! Send us feedback at support@langchain.dev, check out the [Evaluators](https://python.langchain.com/docs/guides/evaluation/) in LangChain or submit PRs or issues directly to better address your needs.