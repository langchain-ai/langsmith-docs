---
sidebar_position: 17
---

import { ConfigureSDKEnvironmentCodeTabs } from "@site/src/components/QuickStart";
import {
  CodeTabs,
  typescript,
} from "@site/src/components/InstructionsWithCode";

# Trace with OpenTelemetry

LangSmith can accept traces from OpenTelemetry based clients.
This guide will walk through examples on how to achieve this.

## Logging Traces with a basic OpenTelemetry client

This first section covers how to use a standard OpenTelemetry client to log traces to LangSmith.

### 1. Installation

Install the OpenTelemetry SDK, OpenTelemetry exporter packages, as well as the OpenAI package:

```bash
pip install openai
pip install opentelemetry-sdk
pip install opentelemetry-exporter-otlp
```

### 2. Configure your environment

Setup environment variables for the endpoint, substitute your specific values:

```bash
OTEL_EXPORTER_OTLP_ENDPOINT=https://api.smith.langchain.com/otel
OTEL_EXPORTER_OTLP_HEADERS="x-api-key=<your langsmith api key>"
```

#### **Optional: Specify a custom project name other than "default"**

```bash
OTEL_EXPORTER_OTLP_ENDPOINT=https://api.smith.langchain.com/otel
OTEL_EXPORTER_OTLP_HEADERS="x-api-key=<your langsmith api key>,Langsmith-Project=<project name>"
```

### 3. Log a trace

This code sets up an OTEL tracer and exporter that will send traces to LangSmith. It then
calls OpenAI and sends the required OpenTelemetry attributes.

```python
from openai import OpenAI
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import (
    BatchSpanProcessor,
)
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

otlp_exporter = OTLPSpanExporter(
    timeout=10,
)
trace.set_tracer_provider(TracerProvider())
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(otlp_exporter)
)
tracer = trace.get_tracer(__name__)

def call_openai():
    model = "gpt-4o-mini"
    with tracer.start_as_current_span("call_open_ai") as span:
        span.set_attribute("langsmith.span.kind", "LLM")
        span.set_attribute("langsmith.metadata.user_id", "user_123")
        span.set_attribute("gen_ai.system", "OpenAI")
        span.set_attribute("gen_ai.request.model", model)
        span.set_attribute("llm.request.type", "chat")
        messages = [
            {"role": "system", "content": "You are a helpful assistant."},
            {
                "role": "user",
                "content": "Write a haiku about recursion in programming."
            }
        ]

        for i, message in enumerate(messages):
            span.set_attribute(f"gen_ai.prompt.{i}.content", str(message["content"]))
            span.set_attribute(f"gen_ai.prompt.{i}.role", str(message["role"]))

        completion = client.chat.completions.create(
            model=model,
            messages=messages
        )

        span.set_attribute("gen_ai.response.model", completion.model)
        span.set_attribute("gen_ai.completion.0.content", str(completion.choices[0].message.content))
        span.set_attribute("gen_ai.completion.0.role", "assistant")
        span.set_attribute("gen_ai.usage.prompt_tokens", completion.usage.prompt_tokens)
        span.set_attribute("gen_ai.usage.completion_tokens", completion.usage.completion_tokens)
        span.set_attribute("gen_ai.usage.total_tokens", completion.usage.total_tokens)
        return completion.choices[0].message

if __name__ == "__main__":
    call_openai()
```

You should see a trace in your LangSmith dashboard [like this one](https://smith.langchain.com/public/4f2890b1-f105-44aa-a6cf-c777dcc27a37/r).

## Supported OpenTelemetry Attribute Mapping

When sending traces to LangSmith via OpenTelemetry, the following attributes are mapped to LangSmith fields.

| OpenTelemetry Attribute            | LangSmith Field                       | Notes                                                                        |
| ---------------------------------- | ------------------------------------- | ---------------------------------------------------------------------------- |
| `langsmith.trace.name`             | Run Name                              | Overrides the span name for the run                                          |
| `langsmith.span.kind`              | Run Type                              | Values: `llm`, `chain`, `tool`, `retriever`, `embedding`, `prompt`, `parser` |
| `langsmith.span.id`                | Run ID                                | Unique identifier for the span                                               |
| `langsmith.trace.id`               | Trace ID                              | Unique identifier for the trace                                              |
| `langsmith.span.dotted_order`      | Dotted Order                          | Position in the execution tree                                               |
| `langsmith.span.parent_id`         | Parent Run ID                         | ID of the parent span                                                        |
| `langsmith.trace.session_id`       | Session ID                            | Session identifier for related traces                                        |
| `langsmith.trace.session_name`     | Session Name                          | Name of the session                                                          |
| `langsmith.span.tags`              | Tags                                  | Custom tags attached to the span                                             |
| `gen_ai.system`                    | `metadata.ls_provider`                | The GenAI system (e.g., "openai", "anthropic")                               |
| `gen_ai.prompt`                    | `inputs`                              | The input prompt sent to the model                                           |
| `gen_ai.completion`                | `outputs`                             | The output generated by the model                                            |
| `gen_ai.prompt.{n}.role`           | `inputs.messages[n].role`             | Role for the nth input message                                               |
| `gen_ai.prompt.{n}.content`        | `inputs.messages[n].content`          | Content for the nth input message                                            |
| `gen_ai.completion.{n}.role`       | `outputs.messages[n].role`            | Role for the nth output message                                              |
| `gen_ai.completion.{n}.content`    | `outputs.messages[n].content`         | Content for the nth output message                                           |
| `gen_ai.request.model`             | `invocation_params.model`             | The model name used for the request                                          |
| `gen_ai.response.model`            | `invocation_params.model`             | The model name returned in the response                                      |
| `gen_ai.request.temperature`       | `invocation_params.temperature`       | Temperature setting                                                          |
| `gen_ai.request.top_p`             | `invocation_params.top_p`             | Top-p sampling setting                                                       |
| `gen_ai.request.max_tokens`        | `invocation_params.max_tokens`        | Maximum tokens setting                                                       |
| `gen_ai.request.frequency_penalty` | `invocation_params.frequency_penalty` | Frequency penalty setting                                                    |
| `gen_ai.request.presence_penalty`  | `invocation_params.presence_penalty`  | Presence penalty setting                                                     |
| `gen_ai.request.seed`              | `invocation_params.seed`              | Random seed used for generation                                              |
| `gen_ai.request.stop_sequences`    | `invocation_params.stop`              | Sequences that stop generation                                               |
| `gen_ai.request.top_k`             | `invocation_params.top_k`             | Top-k sampling parameter                                                     |
| `gen_ai.request.encoding_formats`  | `invocation_params.encoding_formats`  | Output encoding formats                                                      |
| `gen_ai.usage.input_tokens`        | `usage_metadata.input_tokens`         | Number of input tokens used                                                  |
| `gen_ai.usage.output_tokens`       | `usage_metadata.output_tokens`        | Number of output tokens used                                                 |
| `gen_ai.usage.total_tokens`        | `usage_metadata.total_tokens`         | Total number of tokens used                                                  |
| `gen_ai.usage.prompt_tokens`       | `usage_metadata.input_tokens`         | Number of input tokens used (deprecated)                                     |
| `gen_ai.usage.completion_tokens`   | `usage_metadata.output_tokens`        | Number of output tokens used (deprecated)                                    |
| `input.value`                      | `inputs`                              | Full input value, can be string or JSON                                      |
| `output.value`                     | `outputs`                             | Full output value, can be string or JSON                                     |
| `langsmith.metadata.{key}`         | `metadata.{key}`                      | Custom metadata                                                              |

## Logging Traces with the Traceloop SDK

The Traceloop SDK is an OpenTelemetry compatible SDK that covers a range of models, vector databases and frameworks.
If there are integrations that you are interested in instrumenting that are covered by this SDK, you
can use this SDK with OpenTelemetry to log traces to LangSmith.

To see what integrations are supported by the Traceloop SDK, see the [Traceloop SDK documentation](https://www.traceloop.com/docs/openllmetry/tracing/supported).

To get started, follow these steps:

### 1. Installation

```bash
pip install traceloop-sdk
pip install openai
```

### 2. Configure your environment

Setup environment variables:

```bash
TRACELOOP_BASE_URL=https://api.smith.langchain.com/otel
TRACELOOP_HEADERS=x-api-key=<your_langsmith_api_key>
```

#### **Optional: Specify a custom project name other than "default"**

```bash
TRACELOOP_HEADERS=x-api-key=<your_langsmith_api_key>,Langsmith-Project=<langsmith_project_name>
```

### 3. Initialize the SDK

To use the SDK, you need to initialize it before logging traces:

```python
from traceloop.sdk import Traceloop
Traceloop.init()
```

### 4. Log a trace

Here is a complete example using an OpenAI chat completion:

```python
import os
from openai import OpenAI
from traceloop.sdk import Traceloop

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
Traceloop.init()

completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {
            "role": "user",
            "content": "Write a haiku about recursion in programming."
        }
    ]
)

print(completion.choices[0].message)
```

You should see a trace in your LangSmith dashboard [like this one](https://smith.langchain.com/public/106f5bed-edca-4357-91a5-80089252c9ed/r).

## Tracing LangChain with OpenTelemetry

LangChain now provides built-in OpenTelemetry integration, allowing you to trace your LangChain applications using the OpenTelemetry standard and send those traces to LangSmith.

### 1. Installation

Install the LangSmith package with OpenTelemetry support:

```bash
pip install "langsmith[otel]"
pip install langchain
```

### 2. Enable the OpenTelemetry integration

You can enable the OpenTelemetry integration by setting the `LANGSMITH_OTEL_ENABLED` environment variable:

```bash
LANGSMITH_OTEL_ENABLED=true
LANGSMITH_TRACING=true
LANGSMITH_ENDPOINT=https://api.smith.langchain.com
LANGSMITH_API_KEY=<your_langsmith_api_key>
```

### 3. Create a LangChain application with tracing

Here's a simple example showing how to use the OpenTelemetry integration with LangChain:

```python
import os
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# LangChain will automatically use OpenTelemetry to send traces to LangSmith
# because the LANGSMITH_OTEL_ENABLED environment variable is set

# Create a chain
prompt = ChatPromptTemplate.from_template("Tell me a joke about {topic}")
model = ChatOpenAI()
chain = prompt | model

# Run the chain
result = chain.invoke({"topic": "programming"})
print(result.content)
```

### 4. View the traces in LangSmith

Once your application runs, you'll see the traces in your LangSmith dashboard.

## Distributed Tracing with LangChain and OpenTelemetry

Distributed tracing is essential when your LLM application spans multiple services or processes. OpenTelemetry's context propagation capabilities ensure that traces remain connected across service boundaries.

### Context Propagation in Distributed Tracing

In distributed systems, context propagation passes trace metadata between services so that related spans are linked to the same trace:

- **Trace ID**: A unique identifier for the entire trace
- **Span ID**: A unique identifier for the current span
- **Sampling Decision**: Indicates whether this trace should be sampled

### Setting up Distributed Tracing with LangChain

To enable distributed tracing across multiple services:

```python
import os
from opentelemetry import trace
from opentelemetry.propagate import inject, extract
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
import requests
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# Set up OpenTelemetry trace provider
provider = TracerProvider()
otlp_exporter = OTLPSpanExporter(
    endpoint="https://api.smith.langchain.com/otel/v1/traces",
    headers={"x-api-key": os.getenv("LANGSMITH_API_KEY"), "Langsmith-Project": "my_project"}
)
processor = BatchSpanProcessor(otlp_exporter)
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)
tracer = trace.get_tracer(__name__)

# Service A: Create a span and propagate context to Service B
def service_a():
    with tracer.start_as_current_span("service_a_operation") as span:
        # Create a chain
        prompt = ChatPromptTemplate.from_template("Summarize: {text}")
        model = ChatOpenAI()
        chain = prompt | model

        # Run the chain
        result = chain.invoke({"text": "OpenTelemetry is an observability framework"})

        # Propagate context to Service B
        headers = {}
        inject(headers)  # Inject trace context into headers

        # Call Service B with the trace context
        response = requests.post(
            "http://service-b.example.com/process",
            headers=headers,
            json={"summary": result.content}
        )
        return response.json()

# Service B: Extract the context and continue the trace
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/process", methods=["POST"])
def service_b_endpoint():
    # Extract the trace context from the request headers
    context = extract(request.headers)

    with tracer.start_as_current_span("service_b_operation", context=context) as span:
        data = request.json
        summary = data.get("summary", "")

        # Process the summary with another LLM chain
        prompt = ChatPromptTemplate.from_template("Analyze the sentiment of: {text}")
        model = ChatOpenAI()
        chain = prompt | model

        result = chain.invoke({"text": summary})

        return jsonify({"analysis": result.content})

if __name__ == "__main__":
    app.run(port=5000)
```

### Best Practices for Distributed Tracing

1. **Use Consistent Trace IDs**: Ensure all components in your system propagate the same trace ID.
2. **Add Semantic Context**: Include meaningful attributes to spans that help debug issues.
3. **Consider Sampling Strategies**: For high-traffic systems, implement appropriate sampling.
4. **Correlate with Business Transactions**: Link traces to business identifiers like user IDs.

## Sending Traces to Alternate Providers

While LangSmith is the default destination for OpenTelemetry traces, you can also configure OpenTelemetry to send traces to other observability platforms.

### Configuring Alternate OTLP Endpoints

To send traces to a different provider, configure the OTLP exporter with your provider's endpoint:

```python
import os
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# Set environment variables for LangChain
os.environ["LANGSMITH_OTEL_ENABLED"] = "true"
os.environ["LANGSMITH_TRACING"] = "true"

# Configure the OTLP exporter for your custom endpoint
provider = TracerProvider()
otlp_exporter = OTLPSpanExporter(
    # Change to your provider's endpoint
    endpoint="https://otel.your-provider.com/v1/traces",
    # Add any required headers for authentication
    headers={"api-key": "your-api-key"}
)
processor = BatchSpanProcessor(otlp_exporter)
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)

# Create and run a LangChain application
prompt = ChatPromptTemplate.from_template("Tell me a joke about {topic}")
model = ChatOpenAI()
chain = prompt | model

result = chain.invoke({"topic": "programming"})
print(result.content)
```

### Using OpenTelemetry Collector for Fan-out

For more advanced scenarios, you can use the OpenTelemetry Collector to fan out your telemetry data to multiple destinations. This is a more scalable approach than configuring multiple exporters in your application code.

1. **Install the OpenTelemetry Collector**:
   Follow the [official installation instructions](https://opentelemetry.io/docs/collector/getting-started/) for your environment.

2. **Configure the Collector**:
   Create a configuration file (e.g., `otel-collector-config.yaml`) that exports to multiple destinations:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:

exporters:
  otlphttp/langsmith:
    endpoint: https://api.smith.langchain.com/otel/v1/traces
    headers:
      x-api-key: ${env:LANGSMITH_API_KEY}
      Langsmith-Project: my_project

  otlphttp/other_provider:
    endpoint: https://otel.your-provider.com/v1/traces
    headers:
      api-key: ${env:OTHER_PROVIDER_API_KEY}

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/langsmith, otlphttp/other_provider]
```

3. **Configure your application to send to the collector**:

```python
import os
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# Point to your local OpenTelemetry Collector
otlp_exporter = OTLPSpanExporter(
    endpoint="http://localhost:4318/v1/traces"
)

provider = TracerProvider()
processor = BatchSpanProcessor(otlp_exporter)
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)

# Set environment variables for LangChain
os.environ["LANGSMITH_OTEL_ENABLED"] = "true"
os.environ["LANGCHAIN_TRACING_V2"] = "true"

# Create and run a LangChain application
prompt = ChatPromptTemplate.from_template("Tell me a joke about {topic}")
model = ChatOpenAI()
chain = prompt | model

result = chain.invoke({"topic": "programming"})
print(result.content)
```

This approach offers several advantages:

- Centralized configuration for all your telemetry destinations
- Reduced overhead in your application code
- Better scalability and resilience
- Ability to add or remove destinations without changing application code

## Tracing using the Arize SDK

With the Arize SDK and OpenTelemetry, you can log traces from multiple other frameworks to LangSmith.
Below is an example of tracing CrewAI to LangSmith, you can find a full list of supported
frameworks [here](https://docs.arize.com/phoenix/tracing/integrations-tracing). To make this example
work with other frameworks, you just need to change the instrumentor to match the framework.

### 1. Installation

First, install the required packages:

```bash
pip install -qU arize-phoenix-otel openinference-instrumentation-crewai crewai crewai-tools
```

### 2. Configure your environment

Next, set the following environment variables:

```bash
OPENAI_API_KEY=<your_openai_api_key>
SERPER_API_KEY=<your_serper_api_key>
```

### 3. Set up the instrumentor

Before running any application code let's set up our instrumentor (you can replace this with any of the frameworks supported [here](https://docs.arize.com/phoenix/tracing/integrations-tracing))

```python
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

# Add LangSmith API Key for tracing
LANGSMITH_API_KEY = "YOUR_API_KEY"
# Set the endpoint for OTEL collection
ENDPOINT = "https://api.smith.langchain.com/otel/v1/traces"
# Select the project to trace to
LANGSMITH_PROJECT = "YOUR_PROJECT_NAME"

# Create the OTLP exporter
otlp_exporter = OTLPSpanExporter(
    endpoint=ENDPOINT,
    headers={"x-api-key": LANGSMITH_API_KEY, "Langsmith-Project": LANGSMITH_PROJECT}
)

# Set up the trace provider
provider = TracerProvider()
processor = BatchSpanProcessor(otlp_exporter)
provider.add_span_processor(processor)

# Now instrument CrewAI
from openinference.instrumentation.crewai import CrewAIInstrumentor
CrewAIInstrumentor().instrument(tracer_provider=provider)
```

### 4. Log a trace

Now, you can run a CrewAI workflow and the trace will automatically be logged to LangSmith

```python
from crewai import Agent, Task, Crew, Process
from crewai_tools import SerperDevTool

search_tool = SerperDevTool()

# Define your agents with roles and goals
researcher = Agent(
  role='Senior Research Analyst',
  goal='Uncover cutting-edge developments in AI and data science',
  backstory="""You work at a leading tech think tank.
  Your expertise lies in identifying emerging trends.
  You have a knack for dissecting complex data and presenting actionable insights.""",
  verbose=True,
  allow_delegation=False,
  # You can pass an optional llm attribute specifying what model you wanna use.
  # llm=ChatOpenAI(model_name="gpt-3.5", temperature=0.7),
  tools=[search_tool]
)
writer = Agent(
  role='Tech Content Strategist',
  goal='Craft compelling content on tech advancements',
  backstory="""You are a renowned Content Strategist, known for your insightful and engaging articles.
  You transform complex concepts into compelling narratives.""",
  verbose=True,
  allow_delegation=True
)

# Create tasks for your agents
task1 = Task(
  description="""Conduct a comprehensive analysis of the latest advancements in AI in 2024.
  Identify key trends, breakthrough technologies, and potential industry impacts.""",
  expected_output="Full analysis report in bullet points",
  agent=researcher
)

task2 = Task(
  description="""Using the insights provided, develop an engaging blog
  post that highlights the most significant AI advancements.
  Your post should be informative yet accessible, catering to a tech-savvy audience.
  Make it sound cool, avoid complex words so it doesn't sound like AI.""",
  expected_output="Full blog post of at least 4 paragraphs",
  agent=writer
)

# Instantiate your crew with a sequential process
crew = Crew(
  agents=[researcher, writer],
  tasks=[task1, task2],
  verbose= False,
  process = Process.sequential
)

# Get your crew to work!
result = crew.kickoff()

print("######################")
print(result)
```

You should see a trace in your LangSmith project that looks like this:

![](./static/trace_arize.png)
